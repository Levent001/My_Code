[33mcommit 677c391a5e501ea834150efa2cc465de67bcea13[m[33m ([m[1;36mHEAD -> [m[1;32mmain[m[33m)[m
Author: Levent001 <shijinchang@tju.edu.cn>
Date:   Sun Aug 4 23:09:30 2024 +0800

    first commit

[1mdiff --git a/AMBA/AHB2APB_Bridge/rtl/cmsdk_ahb_to_apb.v b/AMBA/AHB2APB_Bridge/rtl/cmsdk_ahb_to_apb.v[m
[1mnew file mode 100644[m
[1mindex 0000000..1ebcca6[m
[1m--- /dev/null[m
[1m+++ b/AMBA/AHB2APB_Bridge/rtl/cmsdk_ahb_to_apb.v[m
[36m@@ -0,0 +1,273 @@[m
[32m+[m[32mmodule cmsdk_ahb_to_apb #([m
[32m+[m[32m    parameter ADDRWIDTH = 16,[m
[32m+[m[32m    parameter REGISTER_RDATA = 1,  //ÈªòËÆ§ÂØπËØªÊï∞ÊçÆËøõË°åÂØÑÂ≠ò[m
[32m+[m[32m    parameter REGISTER_WDATA = 0  //ÂÜôÊï∞ÊçÆÊ≤°ÊúâËøõË°åÂØÑÂ≠ò[m
[32m+[m[32m) ([m
[32m+[m[32m    //-----------------------------------------------------------------[m
[32m+[m[32m    // Port Definitions[m
[32m+[m[32m    //-----------------------------------------------------------------[m
[32m+[m[32m    input wire HCLK,[m
[32m+[m[32m    input wire HRESETn,[m
[32m+[m[32m    input wire PCLKEN,[m
[32m+[m
[32m+[m[32m    input wire                 HSEL,[m
[32m+[m[32m    input wire [ADDRWIDTH-1:0] HADDR,[m
[32m+[m[32m    input wire [          1:0] HTRANS,[m
[32m+[m[32m    input wire [          2:0] HSIZE,[m
[32m+[m[32m    input wire [          3:0] HPROT,[m
[32m+[m[32m    input wire                 HWRITE,[m
[32m+[m[32m    input wire                 HREADY,[m
[32m+[m[32m    input wire [         31:0] HWDATA,[m
[32m+[m
[32m+[m[32m    output reg                 HREADYOUT,[m
[32m+[m[32m    output wire [        31:0] HRDATA,[m
[32m+[m[32m    output wire                HRESP,[m
[32m+[m
[32m+[m[32m    output wire [ADDRWIDTH-1:0] PADDR,[m
[32m+[m[32m    output wire                 PENABLE,[m
[32m+[m[32m    output wire                 PWRITE,[m
[32m+[m[32m    output wire [          3:0] PSTRB,[m
[32m+[m[32m    output wire [          2:0] PPROT,[m
[32m+[m[32m    output wire [         31:0] PWDATA,[m
[32m+[m[32m    output wire                 PSEL,[m
[32m+[m
[32m+[m[32m    output wire                 APBACTIVE,[m
[32m+[m
[32m+[m[32m    input wire [          31:0] PRDATA,[m
[32m+[m[32m    input wire                  PREADY,[m
[32m+[m[32m    input wire                  PSLVERR // Error state for each APB slave[m
[32m+[m[32m);[m
[32m+[m
[32m+[m[32m    //-----------------------------------------------------------------[m
[32m+[m[32m    // internal wires[m
[32m+[m[32m    //-----------------------------------------------------------------[m
[32m+[m
[32m+[m[32m    reg  [ADDRWIDTH-3:0] addr_reg;  //Address sample register[m
[32m+[m[32m    reg                  wr_reg;  //write control sample register[m
[32m+[m[32m    reg  [          2:0] state_reg;  //state for finite state machine[m
[32m+[m
[32m+[m[32m    reg  [          3:0] pstrb_reg;  //byte lane strobe register[m
[32m+[m[32m    wire [          3:0] pstrb_nxt;  //byte lane strobe next state[m
[32m+[m[32m    reg  [          1:0] pprot_reg;  //PPROT register[m
[32m+[m[32m    wire [          1:0] pprot_nxt;  //PPROT register next state[m
[32m+[m
[32m+[m[32m    wire                 apb_select;  //APB bridge is selected[m
[32m+[m[32m    wire                 apb_tran_end;  //Transfer is conpleted on APB[m
[32m+[m[32m    reg  [          2:0] next_state;  //Next state for finite state machine[m
[32m+[m[32m    reg  [         31:0] rwdata_reg;  //Read/Write data sample register[m
[32m+[m
[32m+[m[32m    wire                 reg_rdata_cfg;  //REGISTER_RDATA paramater[m
[32m+[m[32m    wire                 reg_wdata_cfg;  //REGISTER_WDATA paramater[m
[32m+[m
[32m+[m[32m    reg                  sample_wdata_reg;  // Control signal to sample HWDATA[m
[32m+[m
[32m+[m[32m    //-----------------------------------------------------------------[m
[32m+[m[32m    // State machine[m
[32m+[m[32m    //-----------------------------------------------------------------[m
[32m+[m[32m    localparam ST_BITS = 3;[m
[32m+[m
[32m+[m[32m    localparam [ST_BITS-1:0] ST_IDLE = 3'b000;  //idle waiting for transaction[m
[32m+[m[32m    localparam [ST_BITS-1:0] ST_APB_WAIT = 3'b001;  //wait APB transfer, AHBÁöÑÊï∞ÊçÆÂØÑÂ≠ò‰∏ÄÊãç[m
[32m+[m[32m    localparam [ST_BITS-1:0] ST_APB_TRNF = 3'b010;  //start APB transfer[m
[32m+[m[32m    localparam [ST_BITS-1:0] ST_APB_TRNF2 = 3'b011;  //second APB transfer cycle[m
[32m+[m[32m    localparam [ST_BITS-1:0] ST_APB_ENDOK = 3'b100;  //ending cycle for OKAY[m
[32m+[m[32m    localparam [ST_BITS-1:0] ST_APB_ERR1 = 3'b101;  //First cycle for Error response[m
[32m+[m[32m    localparam [ST_BITS-1:0] ST_APB_ERR2 = 3'b110;  //Second cycle for Error response[m
[32m+[m[32m    localparam [ST_BITS-1:0] ST_ILLEGAL = 3'b111;  //illegal state[m
[32m+[m
[32m+[m[32m    //-----------------------------------------------------------------[m
[32m+[m[32m    // start of main code[m
[32m+[m[32m    //-----------------------------------------------------------------[m
[32m+[m[32m    // Configuration signal[m
[32m+[m[32m    assign reg_rdata_cfg = (REGISTER_RDATA == 0) ? 1'b0 : 1'b1;  //ÊòØÂê¶ËøõË°åÂØÑÂ≠ò[m
[32m+[m[32m    assign reg_wdata_cfg = (REGISTER_WDATA == 0) ? 1'b0 : 1'b1;[m
[32m+[m
[32m+[m[32m    // Generate APB bridge select[m
[32m+[m[32m    assign apb_select    = HSEL & HTRANS[1] & HREADY;[m
[32m+[m[32m    // Generate APB transfer ended[m
[32m+[m[32m    assign apb_tran_end  = (state_reg == 3'b011) & PREADY;[m
[32m+[m
[32m+[m[32m    assign pprot_nxt[0]  = HPROT[1];  // (0) Normal,(1) Privileged[m
[32m+[m[32m    assign pprot_nxt[1]  = ~HPROT[0];  // (0) Data,(1) Instruction[m
[32m+[m
[32m+[m[32m    // Byte strobe generation[m
[32m+[m[32m    // - Only enable for write operations[m
[32m+[m[32m    // - For word write transfers (HSIZE[1]=1),all byte strobes are 1[m
[32m+[m[32m    // - For hword write transfers (HSIZE[0]=1),check HADDR[1][m
[32m+[m[32m    // - For byte write transfers,check HADDR[1:0][m
[32m+[m[32m    assign pstrb_nxt[0]  = HWRITE & ((HSIZE[1]) | ((HSIZE[0]) & (~HADDR[1])) | (HADDR[1:0] == 2'b00));[m
[32m+[m[32m    assign pstrb_nxt[1]  = HWRITE & ((HSIZE[1]) | ((HSIZE[0]) & (~HADDR[1])) | (HADDR[1:0] == 2'b01));[m
[32m+[m[32m    assign pstrb_nxt[2]  = HWRITE & ((HSIZE[1]) | ((HSIZE[0]) & (HADDR[1])) | (HADDR[1:0] == 2'b10));[m
[32m+[m[32m    assign pstrb_nxt[3]  = HWRITE & ((HSIZE[1]) | ((HSIZE[0]) & (HADDR[1])) | (HADDR[1:0] == 2'b11));[m
[32m+[m
[32m+[m[32m    // Sample control signals[m
[32m+[m[32m    always @(posedge HCLK or negedge HRESETn) begin[m
[32m+[m[32m        if (~HRESETn) begin[m
[32m+[m[32m            addr_reg  <= {(ADDRWIDTH - 2) {1'b0}};[m
[32m+[m[32m            wr_reg    <= 1'b0;[m
[32m+[m[32m            pprot_reg <= {2{1'b0}};[m
[32m+[m[32m            pstrb_reg <= {4{1'b0}};[m
[32m+[m[32m        end[m
[32m+[m[32m        else if (apb_select) begin[m
[32m+[m[32m            addr_reg  <= HADDR[ADDRWIDTH-1:2];[m
[32m+[m[32m            wr_reg    <= HWRITE;[m
[32m+[m[32m            pprot_reg <= pprot_nxt;[m
[32m+[m[32m            pstrb_reg <= pstrb_nxt;[m
[32m+[m[32m        end[m
[32m+[m[32m    end[m
[32m+[m
[32m+[m[32m    // Sample write data control signal[m
[32m+[m[32m    // Assert after write address phase, deassert after PCLKEN=1[m
[32m+[m[32m    wire sample_wdata_set = apb_select & HWRITE & reg_wdata_cfg;[m
[32m+[m[32m    wire sample_wdata_clr = sample_wdata_reg & PCLKEN;[m
[32m+[m
[32m+[m[32m    always @(posedge HCLK or negedge HRESETn) begin[m
[32m+[m[32m        if (~HRESETn) begin[m
[32m+[m[32m            sample_wdata_reg <= 1'b0;[m
[32m+[m[32m        end[m
[32m+[m[32m        else if (sample_wdata_set | sample_wdata_clr) begin[m
[32m+[m[32m            sample_wdata_reg <= sample_wdata_set;[m
[32m+[m[32m        end[m
[32m+[m[32m    end[m
[32m+[m
[32m+[m[32m    // Generate next state for FSM[m
[32m+[m[32m    // Note : case 3'b111 is not used. The design has been checked that[m
[32m+[m[32m    //        this illegal state cannot be entered using formal verification.[m
[32m+[m[32m    always @(state_reg or PREADY or PSLVERR or apb_select or reg_rdata_cfg or PCLKEN or reg_wdata_cfg or HWRITE) begin[m
[32m+[m[32m        case(state_reg)[m
[32m+[m[32m            //IDLE[m
[32m+[m[32m            ST_IDLE:begin[m
[32m+[m[32m                if(PCLKEN & apb_select & ~(reg_wdata_cfg & HWRITE))[m
[32m+[m[32m                    next_state = ST_APB_TRNF; // Start APB transfer in next cycle[m
[32m+[m[32m                else if (apb_select)[m
[32m+[m[32m                    next_state = ST_APB_WAIT; // Wait for start of APB transfer at PCLKEN high[m
[32m+[m[32m                else[m
[32m+[m[32m                    next_state = ST_IDLE; // Remain idle[m
[32m+[m[32m            end[m
[32m+[m[32m            // Transfer announced on AHB ,but PCLKEN was low,so waiting[m
[32m+[m[32m            ST_APB_WAIT:begin[m
[32m+[m[32m                if(PCLKEN)[m
[32m+[m[32m                    next_state = ST_APB_TRNF; // Start APB transfer in next cycle[m
[32m+[m[32m                else[m
[32m+[m[32m                    next_state = ST_APB_WAIT;// Wait for start of APB transfer at PCLKEN high[m
[32m+[m[32m            end[m
[32m+[m[32m            // First APB transfer cycle[m
[32m+[m[32m            ST_APB_TRNF:begin[m
[32m+[m[32m                if(PCLKEN)[m
[32m+[m[32m                    next_state = ST_APB_TRNF2; // Change to second cycle of APB transfer[m
[32m+[m[32m                else[m
[32m+[m[32m                    next_state = ST_APB_TRNF;  // Change to state-2[m
[32m+[m[32m            end[m
[32m+[m[32m            // Second APB transfer cycle[m
[32m+[m[32m            ST_APB_TRNF2:begin[m
[32m+[m[32m                if(PREADY & PSLVERR & PCLKEN)//Error received - Generate two cycle[m
[32m+[m[32m                    // Error response on AHB by[m
[32m+[m[32m                    next_state = ST_APB_ERR1;//changing to state-5 and 6[m
[32m+[m[32m                else if(PREADY & (~PSLVERR) & PCLKEN) begin //OKAY received[m
[32m+[m[32m                    if(reg_rdata_cfg)[m
[32m+[m[32m                        // Registered version[m
[32m+[m[32m                        next_state = ST_APB_ENDOK;// Generate okay response in state 4[m
[32m+[m[32m                    else[m
[32m+[m[32m                        // Non-registered version[m
[32m+[m[32m                        next_state = {2'b00,apb_select};//Terminate transfer 0:IDLE 1:WAIT[m[41m [m
[32m+[m[32m                end[m
[32m+[m[32m                else // slave not ready[m
[32m+[m[32m                    next_state = ST_APB_TRNF2;[m
[32m+[m[32m            end[m
[32m+[m[32m            // Ending cycle for OKAY (registered response)[m
[32m+[m[32m            ST_APB_ENDOK:begin[m
[32m+[m[32m                if(PCLKEN & apb_select & ~(reg_wdata_cfg & HWRITE))[m
[32m+[m[32m                    next_state = ST_APB_TRNF; //Start APB transfer in next cycle[m
[32m+[m[32m                else if(apb_select) begin[m
[32m+[m[32m                    next_state = ST_APB_WAIT; // Wait for start of APB transfer at PCLKEN hign[m
[32m+[m[32m                end[m
[32m+[m[32m                else[m
[32m+[m[32m                    next_state = ST_IDLE; // Remain IDLE[m
[32m+[m[32m            end[m
[32m+[m[32m            // First cycle for Error response[m
[32m+[m[32m            ST_APB_ERR1:[m
[32m+[m[32m                next_state = ST_APB_ERR2;// Goto 2nd cycle of error response[m
[32m+[m[32m            // Second cycle for Error response[m
[32m+[m[32m            ST_APB_ERR2:begin[m
[32m+[m[32m                if(PCLKEN & apb_select & ~(reg_wdata_cfg & HWRITE))[m
[32m+[m[32m                    next_state = ST_APB_TRNF; // Start APB transfer in next cycle[m
[32m+[m[32m                else if (apb_select)[m
[32m+[m[32m                    next_state = ST_APB_WAIT; // Wait for start of APB transfer at PCLKEN high[m
[32m+[m[32m                else[m
[32m+[m[32m                    next_state = ST_IDLE; // Remain idle[m
[32m+[m[32m            end[m
[32m+[m[32m            default:[m
[32m+[m[32m                next_state = 3'bxxx;[m
[32m+[m[32m        endcase[m
[32m+[m[32m    end[m
[32m+[m
[32m+[m[32m    // Registering state machine[m
[32m+[m[32m    always @(posedge HCLK or negedge HRESETn) begin[m
[32m+[m[32m        if(~HRESETn) begin[m
[32m+[m[32m            state_reg <= 3'b000;[m
[32m+[m[32m        end[m
[32m+[m[32m        else begin[m
[32m+[m[32m            state_reg <= next_state;[m
[32m+[m[32m        end[m
[32m+[m[32m    end[m
[32m+[m
[32m+[m[32m    // Sample PRDATA or HWDATA[m
[32m+[m[32m    always @(posedge HCLK or negedge HRESETn) begin[m
[32m+[m[32m        if(~HRESETn) begin[m
[32m+[m[32m            rwdata_reg <= {32{1'b0}};[m
[32m+[m[32m        end[m
[32m+[m[32m        else begin[m
[32m+[m[32m            if(sample_wdata_reg & reg_wdata_cfg & PCLKEN)[m
[32m+[m[32m                rwdata_reg <= HWDATA;[m
[32m+[m[32m            else if(apb_tran_end & reg_rdata_cfg & PCLKEN) begin[m
[32m+[m[32m                rwdata_reg <= PRDATA;[m
[32m+[m[32m            end[m
[32m+[m[32m        end[m
[32m+[m[32m    end[m
[32m+[m
[32m+[m[32m    // Connect outputs to top level[m
[32m+[m[32m    assign PADDR = {addr_reg,2'b00}; // from sample register Âú∞ÂùÄÂ∑¶Áßª‰∏§‰Ωç[m
[32m+[m[32m    assign PWRITE = wr_reg;// from sample register[m
[32m+[m[41m    [m
[32m+[m[32m    //From sample register or from HWDATA directly[m
[32m+[m[32m    assign PWDATA = (reg_wdata_cfg) ? rwdata_reg : HWDATA;[m
[32m+[m[32m    assign PSEL = (state_reg == ST_APB_TRNF) | (state_reg == ST_APB_TRNF2);[m
[32m+[m[32m    assign PENABLE = (state_reg == ST_APB_TRNF2);[m
[32m+[m[32m    assign PPROT = {pprot_reg[1], 1'b0, pprot_reg[0]};[m
[32m+[m[32m    assign PSTRB = pstrb_reg[3:0];[m
[32m+[m
[32m+[m[32m    // Generate HREADYOUT[m
[32m+[m[32m    always @(state_reg or reg_rdata_cfg or PREADY or PSLVERR or PCLKEN) begin[m
[32m+[m[32m        case(state_reg)[m
[32m+[m[32m            ST_IDLE:      HREADYOUT = 1'b1;[m
[32m+[m[32m            ST_APB_WAIT:  HREADYOUT = 1'b0;[m
[32m+[m[32m            ST_APB_TRNF:  HREADYOUT = 1'b0;[m
[32m+[m[32m            ST_APB_TRNF2: HREADYOUT = (~reg_rdata_cfg) & PREADY & (~PSLVERR) & PCLKEN;[m
[32m+[m[32m            ST_APB_ENDOK: HREADYOUT = reg_rdata_cfg;[m
[32m+[m[32m            ST_APB_ERR1:  HREADYOUT = 1'b0;[m
[32m+[m[32m            ST_APB_ERR2:  HREADYOUT = 1'b1;[m
[32m+[m[32m            default:      HREADYOUT = 1'bx;[m
[32m+[m[32m        endcase[m
[32m+[m[32m    end[m
[32m+[m
[32m+[m[32m    // From sample register or from PRDATA directly[m
[32m+[m[32m    assign HRDATA = (reg_rdata_cfg) ? rwdata_reg : PRDATA;[m
[32m+[m[32m    assign HRESP = (state_reg == ST_APB_ERR1) | (state_reg == ST_APB_ERR2);[m
[32m+[m
[32m+[m[32m    assign APBACTIVE = (HSEL & HTRANS[1]) | (|state_reg);[m
[32m+[m
[32m+[m[32m    `ifdef ARM_APB_ASSERT_ON[m
[32m+[m[32m        //-----------------------------------------------------------------[m
[32m+[m[32m        // Assertions[m
[32m+[m[32m        //-----------------------------------------------------------------[m
[32m+[m[32m        `include "std_ovl_defines.h"[m
[32m+[m[32m        // Capture last read APB data[m
[32m+[m[32m        always @(posedge HCLK or negedge HRESETn) begin[m
[32m+[m[32m            if(~HRESETn)[m
[32m+[m[32m                ovl_last_read_apb_data_reg <= {32{1'b0}};[m
[32m+[m[32m            else if(PREADY & PENABLE & (~PWRITE) & PSEL & PCLKEN)[m
[32m+[m[32m                ovl_last_read_apb_data_reg <= PRDATA;[m
[32m+[m[32m        end[m
[32m+[m[32m    `endif[m
[32m+[m
[32m+[m[32mendmodule  //cmsdk_ahb_to_apb[m
[1mdiff --git a/AMBA/AHB2SRAM/rtl/cmsdk_ahb_to_sram.v b/AMBA/AHB2SRAM/rtl/cmsdk_ahb_to_sram.v[m
[1mnew file mode 100644[m
[1mindex 0000000..893ab73[m
[1m--- /dev/null[m
[1m+++ b/AMBA/AHB2SRAM/rtl/cmsdk_ahb_to_sram.v[m
[36m@@ -0,0 +1,221 @@[m
[32m+[m[32mmodule cmsdk_ahb_to_sram #([m
[32m+[m[32m    //-----------------------------------------------------------------[m
[32m+[m[32m    // Parameter Declarations[m
[32m+[m[32m    //-----------------------------------------------------------------[m
[32m+[m[32m    parameter AW = 16[m
[32m+[m[32m) ([m
[32m+[m[32m    //-----------------------------------------------------------------[m
[32m+[m[32m    // Port Definitions[m
[32m+[m[32m    //-----------------------------------------------------------------[m
[32m+[m[32m    input  wire          HCLK,[m
[32m+[m[32m    input  wire          HRESETn,[m
[32m+[m[32m    input  wire          HSEL,[m
[32m+[m[32m    input  wire          HREADY,[m
[32m+[m[32m    input  wire [   1:0] HTRANS,[m
[32m+[m[32m    input  wire [   2:0] HSIZE,[m
[32m+[m[32m    input  wire          HWRITE,[m
[32m+[m[32m    input  wire [AW-1:0] HADDR,[m
[32m+[m[32m    input  wire [  31:0] HWDATA,[m
[32m+[m[32m    output wire          HREADYOUT,[m
[32m+[m[32m    output wire          HRESP,[m
[32m+[m[32m    output wire [  31:0] HRDATA,[m
[32m+[m
[32m+[m[32m    input  wire [    31:0] SRAMRDATA,[m
[32m+[m[32m    output wire [AW-3 : 0] SRAMADDR,[m
[32m+[m[32m    output wire [     3:0] SRAMWEN,[m
[32m+[m[32m    output wire [    31:0] SRAMWDATA,[m
[32m+[m[32m    output wire            SRAMCS[m
[32m+[m[32m);[m
[32m+[m[32m    //-----------------------------------------------------------------[m
[32m+[m[32m    // Internal state[m
[32m+[m[32m    //-----------------------------------------------------------------[m
[32m+[m[32m    reg [(AW-3):0] buf_addr;  // Write address buffer[m
[32m+[m[32m    reg [     3:0] buf_we;  // Write enable buffer[m
[32m+[m[32m    reg            buf_hit;  // High when AHB read address[m
[32m+[m[32m                             // matches buffed address[m
[32m+[m[32m    reg [    31:0] buf_data; // AHB write bus buffered[m
[32m+[m[32m    reg            buf_pend; // Buffer write data valid[m
[32m+[m[32m    reg            buf_data_en; // Data buffer write enable (data phase)[m
[32m+[m
[32m+[m[32m    //-----------------------------------------------------------------[m
[32m+[m[32m    // Read/write control logic[m
[32m+[m[32m    //-----------------------------------------------------------------[m
[32m+[m
[32m+[m[32m    wire ahb_access = HTRANS[1] & HSEL & HREADY;[m
[32m+[m[32m    wire ahb_write = ahb_access & HWRITE;[m
[32m+[m[32m    wire ahb_read = ahb_access & (~HWRITE);[m
[32m+[m
[32m+[m[32m    // Store write data in pending state if new transfer is read[m
[32m+[m[32m    // buf_data_en indicate new write (data phase)[m
[32m+[m[32m    // ahb_read    indicate new read (address phase)[m
[32m+[m[32m    // buf_pend    is registered version of buf_pend_nxt[m
[32m+[m[32m    wire buf_pend_nxt = (buf_pend | buf_data_en) & (~ahb_read);[m
[32m+[m
[32m+[m[32m    // RAM write happens when[m
[32m+[m[32m    // - write pending (buf_pend),or[m
[32m+[m[32m    // - new AHB write seen (buf_data_en) at data phase[m
[32m+[m[32m    // - and not reading (address phase)[m
[32m+[m[32m    wire ram_write = (buf_pend | buf_data_en) & (~ahb_read); // ahb_write[m
[32m+[m
[32m+[m[32m    // RAM WE is the buffered WE[m
[32m+[m[32m    assign SRAMWEN = {4{ram_write}} & buf_we[3:0];[m
[32m+[m
[32m+[m[32m    // RAM address is the buffered address for RAM write otherwise HADDR[m
[32m+[m[32m    assign SRAMADDR = ahb_read ? HADDR[AW-1:2] : buf_addr;[m
[32m+[m
[32m+[m[32m    // RAM chip select during read or write[m
[32m+[m[32m    assign SRAMCS = ahb_read | ram_write;[m
[32m+[m
[32m+[m[32m    //----------------------